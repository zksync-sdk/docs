---

title: ZKsync Era Features  
description: Explore ZKsync Era features and custom transactions
tags: ["zksync", "ethereum", "zksync Era", "transactions", "paymasters"]

---

ZKsync Era, while mostly Web3-compatible, has key differences compared to Ethereum:

- **Account Abstraction Support**: Allows near-arbitrary validation logic and enables paymaster support.
- **Deployment Transactions**: Contracts' bytecode must be passed in a separate field.
- **Fee System**: Requires additional fields in transactions.

These differences necessitate extending standard Ethereum transactions with new custom fields, known as EIP712
transactions. Refer to the ZKsync documentation on Transaction Lifecycle for details on [EIP712 transactions](https://docs.zksync.io/zk-stack/concepts/transaction-lifecycle#eip-712-0x71).

::callout{icon="i-heroicons-light-bulb"}
This guide focuses on passing these arguments to the SDK.
::

## Overrides

`ethers.js` has a notion of overrides. For any on-chain transaction, `ethers.js` finds the optimal `gasPrice`,
`gasLimit`, `nonce`, and other important fields under the hood. But sometimes, you may have a need to explicitly
provide these values (e.g., setting a smaller `gasPrice` or signing a transaction with a future `nonce`).

In such cases, you can provide an `Overrides` object as the last parameter. There, you can supply fields like
`gasPrice`, `gasLimit`, `nonce`, etc.

To make the SDK as flexible as possible, `zksync-ethers` uses the `customData` object in the overrides to supply
ZKsync-specific fields. To supply ZKsync-specific fields, you need to pass the following override:

```typescript
{
  overrides: {
    customData: {
      gasPerPubdata?: BigNumberish;
      factoryDeps?: BytesLike[];
      customSignature?: BytesLike;
      paymasterParams?: {
        paymaster: Address;
        paymasterInput: BytesLike;
      };
    }
  }
}
```

::callout{icon="i-heroicons-light-bulb"}
Everything that is inside `customData` in `overrides` is related to ZKsync (L2 gas, etc.).
::

### CustomData fields

- `gasPerPubdata`: Specifies L2 gas per published byte.
- `factoryDeps`: Array of contract bytecodes for deployment.
- `customSignature`: Custom signature for the transaction.
- `paymasterParams`: Parameters for using a paymaster.

## Example overrides

### Contract deployment

Override to deploy a contract with bytecode `0xcde...12` and enforce that the operator will not charge more than `100`
L2 gas per published bytes on Layer 1:

```typescript
{
  customData: {
    gasPerPubdata: "100",
    factoryDeps: ["0xcde...12"],
  }
}
```

### Custom signature and paymaster

Use custom signature `0x123456` for the account, while using paymaster with
address `0x8e1DC7E4Bb15927E76a854a92Bf8053761501fdC` and paymaster input `0x8c5a3445`:

```typescript
{
  customData: {
    customSignature: "0x123456",
    paymasterParams: {
      paymaster: "0x8e1DC7E4Bb15927E76a854a92Bf8053761501fdC",
      paymasterInput: "0x8c5a3445"
    }
  }
}
```

## Encoding paymaster params

While the paymaster feature itself does not impose any limitations on values of the `paymasterInput`, the Matter Labs
team endorses certain types of [paymaster flows](https://docs.zksync.io/build/developer-reference/account-abstraction/paymasters#built-in-paymaster-flows)
that are processable by EOAs.

The ZKsync SDK provides a utility method that can be used to get the correctly formed `paymasterParams` object: [getPaymasterParams](/sdk/js/ethers/v5/paymaster-utils#getpaymasterparams).

## Using a paymaster with a contract method

If you want to call the `setGreeting` method of an ethers `Contract` object called `greeter`, this would look the
following way, while paying fees with the [testnet paymaster](https://docs.zksync.io/build/developer-reference/account-abstraction/paymasters#testnet-paymaster):

```typescript
// The `setGreeting` method has a single parameter -- new greeting
// We will set its value as `a new greeting`.
const greeting = "a new greeting";
const tx = await greeter.populateTransaction.setGreeting(greeting);
const gasPrice = await sender.provider.getGasPrice();
const gasLimit = await greeter.estimateGas.setGreeting(greeting);
const fee = gasPrice.mul(gasLimit);

const paymasterParams = utils.getPaymasterParams(testnetPaymaster, {
  type: "ApprovalBased",
  token,
  minimalAllowance: fee,
  innerInput: new Uint8Array(),
});
const sentTx = await sender.sendTransaction({
  ...tx,
  maxFeePerGas: gasPrice,
  maxPriorityFeePerGas: BigNumber.from(0),
  gasLimit,
  customData: {
    gasPerPubdata: utils.DEFAULT_GAS_PER_PUBDATA_LIMIT,
    paymasterParams,
  },
});
```
